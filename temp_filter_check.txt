
  import { DexScreenerClient } from '../api/dexscreener-client';
  
  export interface FilterCriteria {
    minMarketCap?: number;
    minLiquidity?: number;
    minVolume24h?: number;
    minHolders?: number;
    requireLiquidity?: boolean;
    requireName?: boolean; // Skip tokens without proper names
  }
  
  export class SmartTokenFilter extends EventEmitter {
    private dexScreener: DexScreenerClient;
    private filters: Map<string, FilterCriteria> = new Map();
  
    constructor() {
      super();
      this.dexScreener = new DexScreenerClient();
      this.setupDefaultFilters();
    }
  
    private setupDefaultFilters() {
      // Different filter presets - Updated to match user requirements
      this.filters.set('strict', {
        minMarketCap: 1000, // MC > $1K
        minLiquidity: 500,  // Liquidity > $500
        requireLiquidity: true,
        requireName: true
      });
  
      this.filters.set('moderate', {
        minMarketCap: 100,  // MC > $100
        minLiquidity: 100,  // Liquidity > $100 (default)
        requireLiquidity: true,
        requireName: true
      });
  
      this.filters.set('graduation_candidate', {
        minMarketCap: 45000, // MC > $45K
        minLiquidity: 1000,  // Reasonable liquidity requirement
        requireLiquidity: true
      });
  
      this.filters.set('new_with_traction', {
        minLiquidity: 50,    // Any liquidity > $50
        requireLiquidity: true,
        requireName: false   // Allow tokens without proper names for very new tokens
      });
    }
  
>   async shouldProcessToken(token: TokenDiscovery, filterName: string = 'moderate'): Promise<boolean> {
      const criteria = this.filters.get(filterName) || this.filters.get('moderate')!;
  
      // Quick checks first - More lenient name checking
      if (criteria.requireName && (!token.name || 
          token.name === 'Unknown Token' || 
          token.name === 'UNKNOWN' || 
          token.name.trim() === '' ||
          (token.name.includes('PUMP-NEW') && filterName !== 'new_with_traction'))) {
        logger.debug(`Skipping token without proper name: ${token.address} (name: ${token.name})`);
        return false;
      }
  
      // For new_with_traction filter, we're more lenient about names but still want some basic data
      if (filterName === 'new_with_traction' && (!token.address || token.address.length < 32)) {
        logger.debug(`Skipping token with invalid address: ${token.address}`);
        return false;
      }
  
      // Check on DexScreener for market data
      try {
        const pairs = await this.dexScreener.getTokenPairs(token.address);
        
        if (!pairs || pairs.length === 0) {
          // For new_with_traction, allow tokens without trading pairs if they're very new
          if (filterName === 'new_with_traction') {
            const tokenAge = Date.now() - token.createdAt.getTime();
            if (tokenAge < 5 * 60 * 1000) { // Less than 5 minutes old
              logger.info(`Allowing very new token without trading pairs: ${token.symbol} (${Math.round(tokenAge / 1000)}s old)`);
              
              // Emit event with minimal data
              this.emit('tokenPassedFilter', {
                token,
                marketData: {
                  marketCap: 0,
                  liquidity: 0,
                  volume24h: 0,
                  price: 0
                },
                filterName
              });
              
              return true;
            }
          }
          
          logger.debug(`No trading pairs found for ${token.symbol}`);
          return false;
        }
  
        const primaryPair = pairs[0];


