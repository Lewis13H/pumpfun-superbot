// src/api/solsniffer-client.ts
import { BaseAPIClient } from './base-api-client';
import { logger } from '../utils/logger';

export interface SolSnifferTokenAnalysis {
  address: string;
  rugPullRisk: number; // 0-100 score (calculated from risk indicators)
  liquidityLocked: boolean;
  lpBurned: boolean;
  mintAuthorityRenounced: boolean;
  topHolderPercentage: number;
  suspiciousActivity: boolean;
  riskLevel: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  warnings: string[];
  honeypot?: boolean;
  freezeAuthorityRenounced?: boolean;
}

export class SolSnifferClient extends BaseAPIClient {
  constructor(apiKey: string) {
    super('solsniffer', 'https://solsniffer.com/api/v2', apiKey);
    
    // Override headers to include API key in the format Solsniffer expects
    this.client.defaults.headers.common['X-API-Key'] = apiKey;
    this.client.defaults.headers.common['Authorization'] = `Bearer ${apiKey}`;
  }

  async analyzeToken(tokenAddress: string): Promise<SolSnifferTokenAnalysis> {
    try {
      logger.info(`[SOLSNIFFER] Analyzing token ${tokenAddress}`);
      
      // Try with the API key as a query parameter
      const startTime = Date.now();
      const data = await this.makeRequest<any>(
        `/token/${tokenAddress}?apiKey=${this.apiKey}`,
        { method: 'GET' },
        0.01
      );
      
      const responseTime = Date.now() - startTime;
      logger.info(`[SOLSNIFFER] Response received in ${responseTime}ms`, {
        tokenAddress,
        responseKeys: Object.keys(data),
        hasTokenData: !!data.tokenData,
        hasIndicatorData: !!data.tokenData?.indicatorData
      });

      return this.parseResponse(data, tokenAddress);
    } catch (error) {
      logger.error(`[SOLSNIFFER] Error analyzing token ${tokenAddress}:`, error);
      throw error;
    }
  }

  private parseResponse(data: any, tokenAddress: string): SolSnifferTokenAnalysis {
    logger.info(`[SOLSNIFFER] Raw response structure:`, {
      tokenAddress,
      hasTokenData: !!data.tokenData,
      hasTokenInfo: !!data.tokenInfo,
      indicatorKeys: data.tokenData?.indicatorData ? Object.keys(data.tokenData.indicatorData) : []
    });
    
    // Calculate risk score based on indicator data
    let rugPullRisk = 0;
    const warnings: string[] = [];
    
    if (data.tokenData?.indicatorData) {
      const indicators = data.tokenData.indicatorData;
      
      // High risk indicators (add 30 points each)
      if (indicators.high?.count > 0) {
        rugPullRisk += indicators.high.count * 30;
        warnings.push(`${indicators.high.count} high risk indicators found`);
        
        // Parse the details if available
        try {
          const details = JSON.parse(indicators.high.details || '{}');
          if (details['Mintable risks found']) warnings.push('Token is mintable');
          if (details['Freeze risks found']) warnings.push('Token can be frozen');
          if (details['A private wallet owns a significant share of the supply']) warnings.push('High ownership concentration');
        } catch (e) {
          logger.warn('[SOLSNIFFER] Could not parse high risk details');
        }
      }
      
      // Medium risk indicators (add 15 points each)
      if (indicators.medium?.count > 0) {
        rugPullRisk += indicators.medium.count * 15;
        warnings.push(`${indicators.medium.count} medium risk indicators found`);
      }
      
      // Low risk indicators (add 5 points each)
      if (indicators.low?.count > 0) {
        rugPullRisk += indicators.low.count * 5;
        warnings.push(`${indicators.low.count} low risk indicators found`);
      }
      
      // Cap at 100
      rugPullRisk = Math.min(rugPullRisk, 100);
    }
    
    // Extract token info if available
    const tokenInfo = data.tokenInfo || {};
    
    const result = {
      address: tokenAddress,
      rugPullRisk: rugPullRisk, // Now properly calculated from 0-100
      liquidityLocked: tokenInfo.liquidityLocked || false,
      lpBurned: tokenInfo.lpBurned || false,
      mintAuthorityRenounced: !tokenInfo.mintable || false,
      freezeAuthorityRenounced: !tokenInfo.freezable || false,
      topHolderPercentage: tokenInfo.topHolderPercent || 0,
      suspiciousActivity: rugPullRisk > 50,
      honeypot: tokenInfo.isHoneypot || false,
      riskLevel: this.calculateRiskLevel(rugPullRisk / 100), // Convert to 0-1 for risk level
      warnings
    };
    
    logger.info(`[SOLSNIFFER] Analysis complete for ${tokenAddress}`, {
      rugPullRisk: result.rugPullRisk,
      riskLevel: result.riskLevel,
      warningCount: warnings.length
    });
    
    return result;
  }

  private calculateRiskLevel(riskScore: number): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {
    // riskScore is 0-1
    if (riskScore >= 0.8) return 'CRITICAL';
    if (riskScore >= 0.6) return 'HIGH';
    if (riskScore >= 0.4) return 'MEDIUM';
    return 'LOW';
  }

  async getServiceStatus(): Promise<boolean> {
    try {
      await this.makeRequest('/token/So11111111111111111111111111111111111111112', { method: 'GET' }, 0);
      return true;
    } catch {
      return false;
    }
  }
}
